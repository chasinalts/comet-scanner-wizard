{"version":3,"file":"imageHandlers-mTahlW39.js","sources":["../../src/utils/imageHandlers.ts"],"sourcesContent":["export const handleImageUpload = (\n  file: File,\n  onSuccess: (imageUrl: string, imagePreview: string) => void\n) => {\n  // Create a blob URL for preview (this is more efficient for display)\n  const imagePreview = URL.createObjectURL(file);\n\n  // Use FileReader to get a data URL (this is more reliable for storage)\n  const reader = new FileReader();\n\n  reader.onloadend = () => {\n    const imageUrl = reader.result as string;\n    console.log('Image uploaded:', {\n      fileName: file.name,\n      fileSize: file.size,\n      fileType: file.type,\n      imageUrlPrefix: imageUrl.substring(0, 30) + '...',\n      imagePreview\n    });\n    onSuccess(imageUrl, imagePreview);\n  };\n\n  reader.readAsDataURL(file);\n};\n\nexport const cleanupImageUrl = (url: string) => {\n  if (url.startsWith('blob:')) {\n    URL.revokeObjectURL(url);\n  }\n};\n\n/**\n * Resizes an image to the specified dimensions\n * @param file The image file to resize\n * @param maxWidth Maximum width of the resized image\n * @param maxHeight Maximum height of the resized image\n * @returns A promise that resolves to a Blob of the resized image\n */\nexport const resizeImage = (\n  file: File,\n  maxWidth: number,\n  maxHeight: number\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.src = URL.createObjectURL(file);\n\n    image.onload = () => {\n      // Calculate new dimensions while maintaining aspect ratio\n      let width = image.width;\n      let height = image.height;\n\n      if (width > maxWidth) {\n        height = (height * maxWidth) / width;\n        width = maxWidth;\n      }\n\n      if (height > maxHeight) {\n        width = (width * maxHeight) / height;\n        height = maxHeight;\n      }\n\n      // Create a canvas and draw the resized image\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        reject(new Error('Could not get canvas context'));\n        return;\n      }\n\n      ctx.drawImage(image, 0, 0, width, height);\n\n      // Convert the canvas to a blob\n      canvas.toBlob((blob) => {\n        if (blob) {\n          resolve(blob);\n        } else {\n          reject(new Error('Could not create blob from canvas'));\n        }\n      }, file.type);\n\n      // Clean up the blob URL\n      URL.revokeObjectURL(image.src);\n    };\n\n    image.onerror = () => {\n      reject(new Error('Failed to load image'));\n      URL.revokeObjectURL(image.src);\n    };\n  });\n};\n"],"names":["handleImageUpload","file","onSuccess","imagePreview","reader","imageUrl","cleanupImageUrl","url"],"mappings":"AAAa,MAAAA,EAAoB,CAC/BC,EACAC,IACG,CAEG,MAAAC,EAAe,IAAI,gBAAgBF,CAAI,EAGvCG,EAAS,IAAI,WAEnBA,EAAO,UAAY,IAAM,CACvB,MAAMC,EAAWD,EAAO,OACxB,QAAQ,IAAI,kBAAmB,CAC7B,SAAUH,EAAK,KACf,SAAUA,EAAK,KACf,SAAUA,EAAK,KACf,eAAgBI,EAAS,UAAU,EAAG,EAAE,EAAI,MAC5C,aAAAF,CAAA,CACD,EACDD,EAAUG,EAAUF,CAAY,CAClC,EAEAC,EAAO,cAAcH,CAAI,CAC3B,EAEaK,EAAmBC,GAAgB,CAC1CA,EAAI,WAAW,OAAO,GACxB,IAAI,gBAAgBA,CAAG,CAE3B"}